<!--
Copyright 2025 Bloxcraft Studios

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Survival Zombie Game - By: Bloxcraft Studios</title>
<style>
  :root{--ui-bg:#222;--accent:#4b3f2f}
  html,body{height:100%;margin:0;font-family:Inter,Arial;background:#87ceeb;user-select:none}
  #container{display:flex;flex-direction:column;align-items:center;padding:10px}
  canvas{border:10px solid var(--accent);box-sizing:border-box;cursor:crosshair;background:transparent}
  #topUi{margin-top:10px;display:flex;gap:8px;align-items:center}
  button{padding:8px 14px;border-radius:6px;border:none;background:var(--accent);color:white;cursor:pointer;font-weight:600}
  #healthBarWrap{position:fixed;left:12px;top:12px;width:220px;height:22px;border-radius:6px;background:#111;border:2px solid #333;overflow:hidden;z-index:1200}
  #healthBar{height:100%;width:100%;background:linear-gradient(90deg,#2ecc71,#27ae60);transition:width 0.3s}
  /* Inventory modal */
  #invModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:#fff;padding:18px;border-radius:10px;display:none;z-index:1300;width:480px;max-width:94vw}
  .grid{display:grid;gap:8px}
  .inv-grid{grid-template-columns:repeat(4,80px)}
  .craft-grid{grid-template-columns:repeat(3,80px)}
  .slot{width:80px;height:80px;background:#111;border:2px solid #444;border-radius:8px;display:flex;align-items:flex-start;justify-content:center;position:relative;cursor:pointer}
  .slot img{width:64px;height:64px;margin-top:6px;pointer-events:none}
  .count{position:absolute;right:6px;bottom:6px;background:rgba(0,0,0,0.6);padding:2px 6px;border-radius:8px;font-weight:700}
  #craftResult{width:64px;height:64px;border:2px solid #444;display:flex;align-items:center;justify-content:center;flex-direction:column;background:#111;border-radius:8px}
  #msg{height:20px;color:#ff7676;text-align:center;margin-top:8px}
  /* Modals for controls & book */
  .modalOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.8);display:none;align-items:center;justify-content:center;z-index:1400}
  .modalCard{background:#222;color:#fff;padding:18px;border-radius:10px;max-width:600px;max-height:80vh;overflow:auto}
  .closeBtn{position:absolute;right:12px;top:12px;background:var(--accent);color:#fff;border:none;padding:6px 8px;border-radius:6px;cursor:pointer}
  /* Created By: Bloxcraft Studios. Notes Added To Remember What To Edit Incase There Are Buga */
  #inventoryLabel{font-weight:700;color:#fff;margin-bottom:8px}
</style>
</head>
<body>
  <div id="container">
    <canvas id="game" width="960" height="540"></canvas>
    <div id="topUi">
      <button id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="modeBtn">Peaceful Mode</button>
      <button id="controlsBtn">Controls</button>
    </div>
  </div>

  <div id="healthBarWrap" title="Health">
    <div id="healthBar"></div>
  </div>

  <!-- Inventory / Crafting Modal -->
  <div id="invModal" role="dialog" aria-hidden="true">
    <div id="inventoryLabel">Inventory</div>
    <div id="messageArea"></div>
    <div class="grid inv-grid" id="invGrid"></div>

    <h3 style="color:#fff;margin:12px 0 6px">Crafting Grid</h3>
    <div class="grid craft-grid" id="craftGrid"></div>

    <div style="display:flex;align-items:center;gap:12px;margin-top:12px">
      <div id="craftResult"></div>
      <button id="craftBtn" disabled>Craft</button>
    </div>

    <div style="display:flex;justify-content:center;margin-top:12px">
      <button id="closeInvBtn" style="background:#a03">Close</button>
    </div>
    <div id="msg"></div>
  </div>

  <!-- Controls modal -->
  <div id="controlsModal" class="modalOverlay"><div class="modalCard">
    <button class="closeBtn" id="closeControls">X</button>
    <h2>Controls</h2>
    <ul>
      <li><b>A / ←</b> - Move left</li>
      <li><b>D / →</b> - Move right</li>
      <li><b>Hold Shift</b> - Use shield (if crafted)</li>
      <li><b>Left Click (hold)</b> - Shoot bullets towards cursor (infinite ammo). 0.5s attack cooldown.</li>
      <li><b>Right Click (hold)</b> - Break wood/stone blocks anywhere (no need to stand). Shows pixel cracks. Cooldown per block type.</li>
      <li><b>E</b> - Open/Close Inventory & Crafting</li>
      <li><b>Start / Pause / Peaceful</b> - Control game</li>
    </ul>
  </div></div>

  <!-- Craft Book Modal -->
  <div id="bookModal" class="modalOverlay"><div class="modalCard">
    <button class="closeBtn" id="closeBook">X</button>
    <h2>Crafting Book</h2>
    <ul>
      <li><b>Shield</b>: 1 Wood + 1 Stone → Shield</li>
    </ul>
  </div></div>

<script>
/* -------------------------
   Assets (images)
   -------------------------*/
const ASSETS = {
  sky: 'https://bloxcraft-ubg.pages.dev/game-sky.png',
  player: 'https://bloxcraft-ubg.pages.dev/playerhead-survival-game.png',
  wood: 'https://bloxcraft-ubg.pages.dev/game-oak-log-block.png',
  stone: 'https://bloxcraft-ubg.pages.dev/game-stone-block.png',
  grass: 'https://bloxcraft-ubg.pages.dev/game-grass.png',
  zombie: 'https://bloxcraft-ubg.pages.dev/zombie_head.png',
  shield: 'https://bloxcraft-ubg.pages.dev/gameitem_shield.png',
  book: 'https://bloxcraft-ubg.pages.dev/item_book_game.png'
};

// preload images
const IMAGES = {};
let loadedCount = 0;
const assetKeys = Object.keys(ASSETS);
assetKeys.forEach(k=>{
  const img = new Image();
  img.src = ASSETS[k];
  img.onload = ()=>{ loadedCount++; };
  IMAGES[k] = img;
});

/* -------------------------
   Canvas + basic world setup
   -------------------------*/
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const CANVAS_W = canvas.width;
const CANVAS_H = canvas.height;

/* Sky drawing: we'll draw the sky image scaled to canvas each frame */
const skyImg = IMAGES.sky;

/* Grass area */
const GRASS_HEIGHT = 96;
const grassY = CANVAS_H - GRASS_HEIGHT;

/* Player */
const player = {
  w: 64, h: 64,
  x: CANVAS_W/2 - 32,
  y: grassY - 64,
  speed: 4,
  health: 100,
  maxHealth: 100,
  alive: true
};

/* Inventory and crafting */
let inventory = []; // objects {type,name,img,count}
let craftingGrid = new Array(9).fill(null);

/* Game lists */
let groundItems = []; // wood/stone blocks {x,y,type,img,breakTime,lastBroken,breakCooldown}
let droppedItems = []; // items dropped on death
let bullets = []; // bullets {x,y,dx,dy,size}
let zombies = []; // zombies array

/* Game flags */
let started = false;
let paused = false;
let peaceful = false;

/* Input state */
const keys = {};
let mouse = {x:0,y:0,left:false,right:false};
let lastShot = 0;
const playerAttackCooldownMs = 500; // 0.5s

/* Zombies spawn settings */
let lastZombieSpawn = 0;
const zombieSpawnInterval = 4000;

/* Block respawn settings */
const blockRespawnDelays = {
  wood: 4000,
  stone: 6000
};

/* Breaking state for right-click breaking */
let breakingState = null; // {item, startTime}

/* Health regen */
const healthRegenPerSecond = 1.0; // +1% per second

/* Utility helpers */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function now(){return performance.now();}

/* -------------------------
   Initialize ground items (wood & stone)
   -------------------------*/
function placeInitialBlocks(){
  groundItems = [
    makeBlock(160, grassY - 64, 'wood'),
    makeBlock(360, grassY - 64, 'stone'),
    makeBlock(560, grassY - 64, 'wood'),
    makeBlock(760, grassY - 64, 'stone'),
  ];
}
function makeBlock(x,y,type){
  const img = (type === 'wood') ? IMAGES.wood : IMAGES.stone;
  return { 
    x, y, type, img, 
    breakTime: (type==='wood'?300:500), 
    lastBroken: 0, 
    breakCooldown: blockRespawnDelays[type] 
  };
}

/* Respawn a block at random X after delay */
function respawnBlock(type){
  setTimeout(()=>{
    const x = 60 + Math.random()*(CANVAS_W-120);
    groundItems.push(makeBlock(x, grassY - 64, type));
  }, blockRespawnDelays[type]);
}

/* -------------------------
   Inventory helpers
   -------------------------*/
function findInv(type){ return inventory.find(i=>i.type===type); }
function addToInventory(type, name, img, count=1){
  let it = findInv(type);
  if(it){ it.count += count; }
  else inventory.push({type,name,img,count});
  updateInvUI();
}
function removeFromInventory(type, count=1){
  let it = findInv(type);
  if(!it) return false;
  it.count -= count;
  if(it.count <= 0) inventory = inventory.filter(i=>i.type!==type);
  updateInvUI();
  return true;
}

/* -------------------------
   UI references & functions
   -------------------------*/
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const modeBtn = document.getElementById('modeBtn');
const controlsBtn = document.getElementById('controlsBtn');
const healthBar = document.getElementById('healthBar');

const invModal = document.getElementById('invModal');
const invGrid = document.getElementById('invGrid');
const craftGrid = document.getElementById('craftGrid');
const craftResult = document.getElementById('craftResult');
const craftBtn = document.getElementById('craftBtn');
const messageArea = document.getElementById('messageArea');
const closeInvBtn = document.getElementById('closeInvBtn');

const controlsModal = document.getElementById('controlsModal');
const closeControls = document.getElementById('closeControls');

const bookModal = document.getElementById('bookModal');
const closeBook = document.getElementById('closeBook');

/* Buttons */
startBtn.onclick = ()=>{ started = true; paused = false; pauseBtn.textContent="Pause"; };
pauseBtn.onclick = ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; };
modeBtn.onclick = ()=>{ peaceful = !peaceful; modeBtn.textContent = peaceful ? 'Normal Mode' : 'Peaceful Mode'; };
controlsBtn.onclick = ()=>{ controlsModal.style.display = 'flex'; paused = true; };
closeControls.onclick = ()=>{ controlsModal.style.display = 'none'; paused = false; };

/* Inventory modal handlers */
function openInventory(){
  invModal.style.display = 'block';
  paused = true;
  updateInvUI();
}
function closeInventory(){ invModal.style.display = 'none'; paused = false; }
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'e'){
    if(invModal.style.display === 'block') closeInventory();
    else openInventory();
  }
});
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);
closeInvBtn.onclick = closeInventory;

/* Crafting rules */
const recipes = [
  { inputs: ['wood','stone'], result: {type:'shield',name:'Shield',img:IMAGES.shield} }
];

function checkRecipe(){
  const placed = craftingGrid.filter(x=>x).map(x=>x.type).sort();
  for(const r of recipes){
    const need = [...r.inputs].sort();
    if(need.length === placed.length && need.every((v,i)=>v===placed[i])) return r;
  }
  return null;
}
craftBtn.onclick = ()=>{
  const r = checkRecipe();
  if(!r) return;
  // remove one wood and one stone from inventory
  removeFromInventory('wood',1);
  removeFromInventory('stone',1);
  addToInventory(r.result.type, r.result.name, r.result.img, 1);
  craftingGrid = new Array(9).fill(null);
  updateInvUI();
  updateCraftUI();
  showMessage(`Crafted ${r.result.name}!`);
};

/* Update Inventory UI (modal) */
function updateInvUI(){
  invGrid.innerHTML = '';
  inventory.forEach((it,idx)=>{
    const s = document.createElement('div'); s.className='slot';
    const img = document.createElement('img'); img.src = (it.img && it.img.src) ? it.img.src : (it.img||'');
    const c = document.createElement('div'); c.className='count'; c.textContent = it.count;
    s.appendChild(img); s.appendChild(c);
    s.onclick = ()=>{ // add to crafting
      const empty = craftingGrid.findIndex(x=>!x);
      if(empty === -1){ showMessage('Crafting grid full'); return; }
      craftingGrid[empty] = {...it, count:1};
      // remove one from inventory
      removeFromInventory(it.type,1);
      updateInvUI(); updateCraftUI();
    };
    invGrid.appendChild(s);
  });
}
function updateCraftUI(){
  craftGrid.innerHTML = '';
  for(let i=0;i<9;i++){
    const s = document.createElement('div'); s.className='slot';
    const it = craftingGrid[i];
    if(it){ const img = document.createElement('img'); img.src = (it.img.src?it.img.src:it.img); s.appendChild(img); s.onclick = ()=>{ // remove back to inventory
      addToInventory(it.type, it.name, it.img, 1); craftingGrid[i]=null; updateCraftUI(); updateInvUI();
    }; }
    craftGrid.appendChild(s);
  }
  const r = checkRecipe();
  craftResult.innerHTML = '';
  craftBtn.disabled = !r;
  if(r){ const s = document.createElement('img'); s.src = r.result.img.src; s.style.width='48px'; s.style.height='48px'; craftResult.appendChild(s); const t = document.createElement('div'); t.style.color='#fff'; t.textContent = r.result.name; craftResult.appendChild(t); }
}

/* message helper */
let msgTimer = null;
function showMessage(t){
  messageArea.textContent = t;
  clearTimeout(msgTimer);
  msgTimer = setTimeout(()=>{ if(messageArea.textContent===t) messageArea.textContent=''; },3000);
}

/* -------------------------
   Input (mouse) handling
   -------------------------*/
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('mousedown', e=>{
  if(e.button===0) mouse.left = true;
  if(e.button===2) {
    mouse.right = true;
    e.preventDefault(); // prevent context menu
  }
});
canvas.addEventListener('mouseup', e=>{
  if(e.button===0) mouse.left = false;
  if(e.button===2) mouse.right = false;
});
canvas.addEventListener('contextmenu', e=> e.preventDefault());

/* -------------------------
   Breaking: pixel-art cracks
   -------------------------*/
/* We'll draw pixel-art cracks by rendering a small grid of "broken" pixels,
   scaled up to fit the block. The pattern will be composed of lines/blocks
   to mimic Minecraft cracks. No external images required. */

function drawBlockCrack(x,y,size,progress){
  // progress 0..1 — number of "crack lines" or area to show increases with progress
  // We'll render a 8x8 pixel grid scaled to block
  const px = 8;
  const cell = size / px;
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.lineWidth = Math.max(1, Math.floor(cell*0.15));
  // Determine number of crack "segments" from progress
  const segments = Math.floor(progress * 20);
  // We'll randomly generate consistent pattern per block by using x,y seed
  const seed = Math.floor(x*7 + y*13);
  function rng(n){ // deterministic pseudo-random
    return (Math.sin(seed + n)*10000) % 1;
  }
  // Draw vertical and horizontal crack lines randomly based on segments count
  let count = 0;
  for(let i=1; i<px && count < segments; i++){
    if(rng(i) > 0.3){
      // vertical line
      ctx.beginPath();
      ctx.moveTo(x + i*cell, y);
      ctx.lineTo(x + i*cell, y + size);
      ctx.stroke();
      count++;
      if(count>=segments) break;
    }
    if(rng(i+10) > 0.3 && count < segments){
      // horizontal line
      ctx.beginPath();
      ctx.moveTo(x, y + i*cell);
      ctx.lineTo(x + size, y + i*cell);
      ctx.stroke();
      count++;
    }
  }
  ctx.restore();
}

/* -------------------------
   Player movement & shield use
   -------------------------*/
let shieldActive = false;
function updatePlayer(){
  if(!player.alive) return;

  // Movement left/right
  if(keys.a || keys.arrowleft) player.x -= player.speed;
  if(keys.d || keys.arrowright) player.x += player.speed;

  // clamp inside canvas
  player.x = clamp(player.x, 0, CANVAS_W - player.w);

  // Shield activation (if player has shield)
  shieldActive = keys.shift && findInv('shield');

  // Health regen in peaceful mode
  if(peaceful && player.health < player.maxHealth){
    player.health += healthRegenPerSecond * (deltaTime/1000);
    if(player.health > player.maxHealth) player.health = player.maxHealth;
  }
}

/* -------------------------
   Bullets: fire left-click
   -------------------------*/
function fireBullet(){
  if(!player.alive) return;
  if(!mouse.left) return;
  if(now() - lastShot < playerAttackCooldownMs) return;

  // direction from player center to mouse
  const px = player.x + player.w/2;
  const py = player.y + player.h/2;
  const dx = mouse.x - px;
  const dy = mouse.y - py;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if(dist < 5) return; // prevent division by zero or shooting backwards

  const speed = 10;
  const vx = (dx/dist)*speed;
  const vy = (dy/dist)*speed;

  bullets.push({x:px,y:py,dx:vx,dy:vy,size:8});
  lastShot = now();
}

/* -------------------------
   Zombies: spawn and move towards player
   -------------------------*/
function spawnZombie(){
  if(peaceful) return;
  if(now() - lastZombieSpawn < zombieSpawnInterval) return;

  const x = Math.random() < 0.5 ? -60 : CANVAS_W + 60;
  const y = grassY - 64;
  zombies.push({
    x, y,
    w:64, h:64,
    speed:1.5,
    health: 30,
    alive:true,
  });
  lastZombieSpawn = now();
}

function updateZombies(){
  zombies = zombies.filter(z=>z.alive);
  zombies.forEach(z=>{
    // Move toward player
    const dir = (player.x + player.w/2 < z.x + z.w/2) ? -1 : 1;
    z.x += dir * z.speed;

    // Attack player if close
    const touching = Math.abs((z.x + z.w/2) - (player.x + player.w/2)) < 40;
    if(touching && z.alive && player.alive){
      if(!shieldActive) player.health -= 0.5;
      if(player.health <= 0){
        player.alive = false;
        player.health = 0;
        showMessage('You died! Press Start to retry.');
      }
    }
  });
}

/* -------------------------
   Bullets update and collision with zombies
   -------------------------*/
function updateBullets(){
  bullets = bullets.filter(b=>{
    b.x += b.dx;
    b.y += b.dy;

    // Remove if off-screen
    if(b.x < 0 || b.x > CANVAS_W || b.y < 0 || b.y > CANVAS_H) return false;

    // Check collision with zombies
    for(let z of zombies){
      if(z.alive &&
        b.x > z.x && b.x < z.x + z.w &&
        b.y > z.y && b.y < z.y + z.h
      ){
        z.health -= 10;
        if(z.health <= 0){
          z.alive = false;
          addToInventory('wood', 'Wood', IMAGES.wood, 1);
        }
        return false; // bullet removed on hit
      }
    }
    return true;
  });
}

/* -------------------------
   Breaking blocks by right click
   -------------------------*/
function updateBreaking(){
  if(mouse.right){
    if(!breakingState){
      // Find block under mouse that can be broken and off cooldown
      const block = groundItems.find(b=>
        mouse.x > b.x && mouse.x < b.x + 64 &&
        mouse.y > b.y && mouse.y < b.y + 64 &&
        now() - b.lastBroken > b.breakCooldown
      );
      if(block){
        breakingState = {item: block, startTime: now()};
      }
    } else {
      const progress = (now() - breakingState.startTime) / breakingState.item.breakTime;
      if(progress >= 1){
        // Break block
        addToInventory(breakingState.item.type, 
          breakingState.item.type.charAt(0).toUpperCase() + breakingState.item.type.slice(1),
          breakingState.item.img, 1);
        breakingState.item.lastBroken = now();
        breakingState.item.breakCooldown = (breakingState.item.type === 'wood') ? blockRespawnDelays.wood : blockRespawnDelays.stone;
        groundItems = groundItems.filter(g=>g!==breakingState.item);
        respawnBlock(breakingState.item.type);
        breakingState = null;
      }
    }
  } else {
    breakingState = null;
  }
}

/* -------------------------
   Draw function: everything
   -------------------------*/
let lastFrameTime = 0;
let deltaTime = 0;
function draw(){
  // Clear canvas
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

  // Draw sky (simple blue bg for now)
  ctx.fillStyle = '#87ceeb';
  ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

  // Draw grass
  ctx.drawImage(IMAGES.grass, 0, grassY, CANVAS_W, GRASS_HEIGHT);

  // Draw ground blocks
  groundItems.forEach(b=>{
    ctx.drawImage(b.img, b.x, b.y, 64, 64);
  });

  // Draw player
  if(player.alive) ctx.drawImage(IMAGES.player, player.x, player.y, player.w, player.h);
  else {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }

  // Draw bullets
  bullets.forEach(b=>{
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(b.x,b.y,b.size/2,b.size/2,0,0,Math.PI*2);
    ctx.fill();
  });

  // Draw zombies
  zombies.forEach(z=>{
    if(z.alive) ctx.drawImage(IMAGES.zombie, z.x, z.y, z.w, z.h);
  });

  // Draw shield over player if active
  if(shieldActive){
    ctx.globalAlpha = 0.6;
    ctx.drawImage(IMAGES.shield, player.x-12, player.y-12, player.w+24, player.h+24);
    ctx.globalAlpha = 1;
  }

  // Draw breaking cracks pixel-art style
  if(breakingState){
    const b = breakingState.item;
    const progress = clamp((now() - breakingState.startTime) / b.breakTime, 0, 1);
    drawBlockCrack(b.x, b.y, 64, progress);
  }
}

/* -------------------------
   Main game loop
   -------------------------*/
function gameLoop(ts){
  deltaTime = ts - lastFrameTime;
  lastFrameTime = ts;

  if(started && !paused){
    updatePlayer();
    fireBullet();
    updateBullets();
    spawnZombie();
    updateZombies();
    updateBreaking();
  }
  draw();
  updateHealthBar();

  requestAnimationFrame(gameLoop);
}

/* -------------------------
   Health bar update
   -------------------------*/
function updateHealthBar(){
  const w = (player.health/player.maxHealth)*100;
  healthBar.style.width = `${w}%`;
  if(w > 60) healthBar.style.background = 'linear-gradient(90deg,#2ecc71,#27ae60)';
  else if(w > 30) healthBar.style.background = 'linear-gradient(90deg,#f1c40f,#f39c12)';
  else healthBar.style.background = 'linear-gradient(90deg,#e74c3c,#c0392b)';
}

/* -------------------------
   Setup initial game state
   -------------------------*/
function resetGame(){
  player.x = CANVAS_W/2 - 32;
  player.y = grassY - 64;
  player.health = player.maxHealth;
  player.alive = true;
  bullets = [];
  zombies = [];
  inventory = [];
  craftingGrid = new Array(9).fill(null);
  breakingState = null;
  placeInitialBlocks();
  updateInvUI();
  updateCraftUI();
  showMessage('Game Started!');
}
resetGame();

/* -------------------------
   Start game loop
   -------------------------*/
requestAnimationFrame(gameLoop);

/* -------------------------
   Book modal handlers
   -------------------------*/
controlsBtn.onclick = ()=>{
  controlsModal.style.display = 'flex';
  paused = true;
};
closeControls.onclick = ()=>{
  controlsModal.style.display = 'none';
  paused = false;
};

closeBook.onclick = ()=>{ bookModal.style.display = 'none'; };

/* -------------------------
   Accessibility & focus trap for modal omitted for brevity
   -------------------------*/
</script>
</body>
</html>
