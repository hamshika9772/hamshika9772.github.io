<!-- Copyright (c) 2025 Bloxcraft Studios -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Player V.S Zombies - By: Bloxcraft Studios</title>
<style>
  :root{
    --bg:#071018; --panel:#081323; --accent:#ff6b6b; --accent2:#4cc9f0; --muted:#9aa8b2;
    --hud-bg: rgba(0,0,0,0.25);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#e6eef8;background:linear-gradient(180deg,#051218,#071a25);}
  .center{display:flex;align-items:center;justify-content:center;height:100%}
  canvas{display:block;border-radius:12px;background:linear-gradient(180deg,#08202a,#04121a);box-shadow:0 10px 30px rgba(2,6,23,0.6)}
  /* overlays & UI */
  .overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:60; backdrop-filter: blur(6px); }
  .card{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; min-width:280px; max-width:620px; text-align:center; color:inherit; }
  h1{margin:0 0 8px 0;font-size:20px}
  p.small{margin:0 0 12px;color:var(--muted)}
  .controls{display:flex;gap:12px;justify-content:center;flex-wrap:wrap}
  .btn{background:var(--accent);color:#071018;padding:10px 14px;border-radius:10px;border:none;font-weight:700;cursor:pointer}
  .btn.alt{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .hud{position:fixed;left:12px;top:12px;z-index:50;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-size:14px}
  .hud .row{display:flex;gap:14px;align-items:center}
  .right-hud{position:fixed;right:12px;top:12px;z-index:50;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-size:14px}
  .mobile-controls{position:fixed;left:12px;right:12px;bottom:12px;z-index:70;display:flex;justify-content:space-between;align-items:flex-end;gap:12px}
  .joystick{width:120px;height:120px;border-radius:999px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;touch-action:none}
  .stick{width:48px;height:48px;border-radius:999px;background:linear-gradient(180deg,#83c5be,#2b8e84);box-shadow:0 6px 14px rgba(0,0,0,0.6);transform:translate(0,0)}
  .aim-stick{width:56px;height:56px;border-radius:999px;background:linear-gradient(180deg,#ffd166,#ffb703);box-shadow:0 6px 14px rgba(0,0,0,0.6)}
  .shoot-btn{width:80px;height:80px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#ff7b7b);display:flex;align-items:center;justify-content:center;font-weight:900;color:#071018;box-shadow:0 10px 20px rgba(0,0,0,0.6);touch-action:none}
  .hint{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;color:var(--muted);font-size:13px;z-index:40}
  .gameover{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:80;background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.6));}
  .level-info{position:fixed;left:50%;transform:translateX(-50%);top:12px;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-weight:700}
  .small-muted{font-size:12px;color:var(--muted)}
  kbd{background:rgba(255,255,255,0.04);padding:2px 6px;border-radius:6px;font-weight:700}
  @media (max-width:720px){
    canvas{width:100%;height:100%}
    .hud{left:8px;top:8px}
    .right-hud{right:8px;top:8px}
    .mobile-controls{left:8px;right:8px;bottom:8px}
  }
</style>
</head>
<body>
  <!-- Start overlay: pick device or auto-detect -->
  <div id="startOverlay" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <h1>Player V.S Zombies - By: Bloxcraft Studios</h1>
      <p class="small">Select how you want to play. Buttons respond to both <strong>click</strong> and <strong>tap</strong>.</p>
      <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
        <button id="autoBtn" class="btn">Auto-detect device</button>
        <button id="desktopBtn" class="btn alt">Desktop — Keyboard + Mouse</button>
        <button id="mobileBtn" class="btn alt">Mobile — Dual-stick</button>
      </div>
      <p class="small" style="margin-top:12px">Desktop: <kbd>W A S D</kbd> or arrows to move, mouse to aim, click to shoot. Mobile: left stick to move, right stick to aim (auto-fire while aiming).</p>
      <div style="margin-top:8px;font-size:13px" class="small-muted">Best Score & Level saved locally.</div>
    </div>
  </div>

  <!-- HUD -->
  <div id="hud" class="hud" style="display:none">
    <div class="row"><div>Score: <span id="score">0</span></div><div>Health: <span id="health">100</span></div></div>
    <div style="margin-top:6px" class="small-muted">Zombies left: <span id="zleft">0</span></div>
  </div>
  <div id="rightHud" class="right-hud" style="display:none">
    <div>Level: <span id="level">1</span> / 100</div>
    <div class="small-muted">Best Level: <span id="bestLevel">0</span></div>
  </div>
  <div id="levelInfo" class="level-info" style="display:none">Wave <span id="waveNum">1</span> — <span id="waveType">Standard</span></div>

  <!-- Canvas -->
  <div class="center">
    <canvas id="gameCanvas" width="1080" height="720" style="max-width:96vw;max-height:88vh"></canvas>
  </div>

  <!-- Mobile controls -->
  <div id="mobileControls" class="mobile-controls" style="display:none">
    <div class="joystick" id="moveBase"><div class="stick" id="moveStick"></div></div>
    <div style="display:flex;flex-direction:column;gap:10px;align-items:center">
      <div class="joystick" id="aimBase" style="width:110px;height:110px"><div class="aim-stick" id="aimStick"></div></div>
      <div class="small-muted">Aim to auto-fire</div>
    </div>
  </div>

  <div id="hint" class="hint">Press <kbd>Space</kbd> to pause</div>

  <!-- Game Over / Level Complete -->
  <div id="gameover" class="gameover" style="display:none">
    <div class="card">
      <h2 id="goTitle">You died</h2>
      <p class="small" id="goText">Score: 0 • Reached level 1</p>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button id="restartBtn" class="btn">Restart</button>
        <button id="changeBtn" class="btn alt">Change Device</button>
      </div>
    </div>
  </div>

<script>
/* Very Great Zombie Game — 100 Levels (single file)
   Features:
   - 100 levels
   - Multiple zombie types (Slow, Runner, Tank, Exploder, Boss)
   - Desktop: WASD/arrow keys + mouse aim + click to shoot
   - Mobile: Dual-stick (left move, right aim) with auto-fire while aiming
   - Level progression: kill all zombies to advance
   - Persistent best score & level in localStorage
*/

/* ---- Canvas & Resize ---- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;

function resizeCanvas() {
  const ratio = W / H;
  const vw = Math.min(window.innerWidth - 24, 1400);
  const vh = Math.min(window.innerHeight - 48, 1000);
  let newW = vw, newH = Math.round(vw / ratio);
  if (newH > vh) { newH = vh; newW = Math.round(vh * ratio); }
  canvas.style.width = newW + 'px';
  canvas.style.height = newH + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
function fixHiDPI(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  resizeCanvas();
}
fixHiDPI();

/* ---- Game State ---- */
const MAX_LEVEL = 100;
let state = {
  running: false,
  paused: false,
  mode: 'desktop', // desktop | mobile
  level: 1,
  score: 0,
  player: null,
  zombies: [],
  bullets: [],
  lastSpawn: 0,
  spawnInterval: 1000,
  pointer: { x: W/2, y: H/2 },
  lastTs: 0,
  bestScore: 0,
  bestLevel: 0
};

/* load bests */
try {
  const saved = JSON.parse(localStorage.getItem('vz_best')||'{}');
  state.bestScore = saved.score || 0;
  state.bestLevel = saved.level || 0;
} catch(e) { state.bestScore = 0; state.bestLevel = 0; }

/* ---- Utility ---- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(a,b,c,d){ return Math.hypot(a-c,b-d); }

/* ---- Player ---- */
function createPlayer(){
  return {
    x: W/2, y: H/2, r: 16,
    speed: 240, vx:0, vy:0,
    health: 100,
    fireRate: 160, lastShot:0,
    dmg: 1
  };
}

/* ---- Zombie types ----
   type: 'walker' | 'runner' | 'tank' | 'exploder' | 'boss'
*/
function zombieTemplate(type, level){
  // base stats scale with level
  const difficulty = Math.max(1, Math.min(10, Math.floor(level/10)+1));
  if(type === 'walker'){
    return { r: rand(12,18), speed: rand(30,50) + level*0.4, hp: 1 + Math.floor(level/10), color:'#6fb98f', score:10 };
  }
  if(type === 'runner'){
    return { r: rand(10,14), speed: rand(80,140) + level*0.8, hp: 1, color:'#f6bd60', score:12 };
  }
  if(type === 'tank'){
    return { r: rand(20,30), speed: rand(18,34) + level*0.2, hp: 3 + Math.floor(level/5), color:'#8e6c88', score:25 };
  }
  if(type === 'exploder'){
    return { r: rand(12,18), speed: rand(60,100) + level*0.6, hp:1, color:'#ff6b6b', score:18, explode:true, explodeRadius:48 + level*0.6 };
  }
  if(type === 'boss'){
    return { r: 46 + Math.min(40,level*0.6), speed: 40 + level*0.6, hp: 20 + level*4, color:'#ffd166', score: 200, boss:true };
  }
  // default walker
  return { r: 14, speed: 40 + level*0.4, hp:1, color:'#6fb98f', score:10 };
}

/* spawn a zombie around edges */
function spawnZombie(level, type=null){
  const side = Math.floor(rand(0,4));
  let x,y;
  const margin = 60;
  if(side===0){ x = -margin; y = rand(0,H); }
  else if(side===1){ x = W+margin; y = rand(0,H); }
  else if(side===2){ x = rand(0,W); y = -margin; }
  else { x = rand(0,W); y = H+margin; }

  if(!type){
    // pick types based on level progression
    const p = Math.random();
    if(level >= 90 && p < 0.07) type = 'boss';
    else if(level >= 50 && p < 0.12) type = 'tank';
    else if(level >= 30 && p < 0.14) type = 'exploder';
    else if(level >= 8 && p < 0.2) type = 'runner';
    else type = 'walker';
  }
  const t = zombieTemplate(type, level);
  const z = { x, y, type, r: t.r, speed: t.speed, hp: t.hp, color: t.color, score: t.score };
  if(t.explode) { z.explode = true; z.explodeRadius = t.explodeRadius; }
  if(t.boss) { z.boss = true; z.hp = t.hp; z.score = t.score; }
  state.zombies.push(z);
}

/* ---- Input Handling ---- */
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.code === 'Space') state.paused = !state.paused;
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

/* Mouse aiming and shooting */
let mouseDown = false;
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  state.pointer.x = (e.clientX - rect.left) * scaleX;
  state.pointer.y = (e.clientY - rect.top) * scaleY;
});
canvas.addEventListener('mousedown', e => { mouseDown = true; tryShoot(); });
canvas.addEventListener('mouseup', e => { mouseDown = false; });
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  state.pointer.x = (t.clientX - rect.left) * scaleX;
  state.pointer.y = (t.clientY - rect.top) * scaleY;
  if(state.mode === 'desktop'){ tryShoot(); } // let touch act as click on desktop mode
}, {passive:false});
canvas.addEventListener('touchmove', e => {
  const t = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  state.pointer.x = (t.clientX - rect.left) * scaleX;
  state.pointer.y = (t.clientY - rect.top) * scaleY;
}, {passive:true});

/* ---- Shooting / Bullets ---- */
function tryShoot(){
  const now = performance.now();
  const p = state.player;
  if(!p) return;
  if(now - p.lastShot < p.fireRate) return;
  p.lastShot = now;
  const dirX = state.pointer.x - p.x, dirY = state.pointer.y - p.y;
  const mag = Math.hypot(dirX,dirY) || 1;
  const speed = 980;
  const b = {
    x: p.x + (dirX/mag)*(p.r+8),
    y: p.y + (dirY/mag)*(p.r+8),
    vx: (dirX/mag) * speed,
    vy: (dirY/mag) * speed,
    r: 4,
    life: 1200,
    dmg: p.dmg
  };
  state.bullets.push(b);
}

/* ---- Mobile Dual Stick ---- */
const moveBase = document.getElementById('moveBase'), moveStick = document.getElementById('moveStick');
const aimBase = document.getElementById('aimBase'), aimStick = document.getElementById('aimStick');

let moveJoy = { active:false, id:null, startX:0, startY:0, dx:0, dy:0, max:42 };
let aimJoy = { active:false, id:null, startX:0, startY:0, dx:0, dy:0, max:44 };

// helper to convert stick screen coords to velocities
function applyMoveJoy(){
  const p = state.player; if(!p) return;
  const dx = moveJoy.dx, dy = moveJoy.dy;
  const mag = Math.hypot(dx,dy);
  if(mag < 6){ p.vx = 0; p.vy = 0; return; }
  p.vx = (dx/mag) * p.speed;
  p.vy = (dy/mag) * p.speed;
}
function applyAimJoy(){
  const mag = Math.hypot(aimJoy.dx, aimJoy.dy);
  if(mag < 6) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  // aim pointer relative to player
  const p = state.player;
  if(!p) return;
  state.pointer.x = p.x + (aimJoy.dx / aimJoy.max) * 200;
  state.pointer.y = p.y + (aimJoy.dy / aimJoy.max) * 200;
  // auto-shoot while aiming
  tryShoot();
}

/* touch listeners: move joystick */
moveBase.addEventListener('touchstart', e => {
  const t = e.changedTouches[0];
  moveJoy.active = true; moveJoy.id = t.identifier;
  const rect = moveBase.getBoundingClientRect();
  moveJoy.startX = rect.left + rect.width/2;
  moveJoy.startY = rect.top + rect.height/2;
}, {passive:true});
moveBase.addEventListener('touchmove', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== moveJoy.id) continue;
    moveJoy.dx = clamp(t.clientX - moveJoy.startX, -moveJoy.max, moveJoy.max);
    moveJoy.dy = clamp(t.clientY - moveJoy.startY, -moveJoy.max, moveJoy.max);
    moveStick.style.transform = `translate(${moveJoy.dx}px, ${moveJoy.dy}px)`;
    applyMoveJoy();
  }
}, {passive:true});
moveBase.addEventListener('touchend', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== moveJoy.id) continue;
    moveJoy.active = false; moveJoy.id = null; moveJoy.dx=0; moveJoy.dy=0;
    moveStick.style.transform = `translate(0px,0px)`; applyMoveJoy();
  }
}, {passive:true});

/* aim joystick */
aimBase.addEventListener('touchstart', e => {
  const t = e.changedTouches[0];
  aimJoy.active = true; aimJoy.id = t.identifier;
  const rect = aimBase.getBoundingClientRect();
  aimJoy.startX = rect.left + rect.width/2;
  aimJoy.startY = rect.top + rect.height/2;
}, {passive:true});
aimBase.addEventListener('touchmove', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== aimJoy.id) continue;
    aimJoy.dx = clamp(t.clientX - aimJoy.startX, -aimJoy.max, aimJoy.max);
    aimJoy.dy = clamp(t.clientY - aimJoy.startY, -aimJoy.max, aimJoy.max);
    aimStick.style.transform = `translate(${aimJoy.dx}px, ${aimJoy.dy}px)`;
    applyAimJoy();
  }
}, {passive:true});
aimBase.addEventListener('touchend', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== aimJoy.id) continue;
    aimJoy.active = false; aimJoy.id = null; aimJoy.dx=0; aimJoy.dy=0;
    aimStick.style.transform = `translate(0px,0px)`;
  }
}, {passive:true});

/* mouse drag support for sticks (desktop-friendly) */
let moveMouseDown=false, aimMouseDown=false;
moveBase.addEventListener('mousedown', e => {
  moveMouseDown=true;
  const rect = moveBase.getBoundingClientRect();
  moveJoy.startX = rect.left + rect.width/2; moveJoy.startY = rect.top + rect.height/2;
});
window.addEventListener('mousemove', e => {
  if(moveMouseDown){
    moveJoy.dx = clamp(e.clientX - moveJoy.startX, -moveJoy.max, moveJoy.max);
    moveJoy.dy = clamp(e.clientY - moveJoy.startY, -moveJoy.max, moveJoy.max);
    moveStick.style.transform = `translate(${moveJoy.dx}px, ${moveJoy.dy}px)`; applyMoveJoy();
  }
  if(aimMouseDown){
    aimJoy.dx = clamp(e.clientX - aimJoy.startX, -aimJoy.max, aimJoy.max);
    aimJoy.dy = clamp(e.clientY - aimJoy.startY, -aimJoy.max, aimJoy.max);
    aimStick.style.transform = `translate(${aimJoy.dx}px, ${aimJoy.dy}px)`; applyAimJoy();
  }
});
window.addEventListener('mouseup', e => {
  if(moveMouseDown){ moveMouseDown=false; moveJoy.dx=0; moveJoy.dy=0; moveStick.style.transform='translate(0px,0px)'; applyMoveJoy(); }
  if(aimMouseDown){ aimMouseDown=false; aimJoy.dx=0; aimJoy.dy=0; aimStick.style.transform='translate(0px,0px)'; }
});
aimBase.addEventListener('mousedown', e => {
  aimMouseDown=true;
  const rect = aimBase.getBoundingClientRect();
  aimJoy.startX = rect.left + rect.width/2; aimJoy.startY = rect.top + rect.height/2;
});

/* ---- Update & Render ---- */
function update(dt){
  if(state.paused || !state.running) return;
  const p = state.player;
  // spawn logic: per level spawn all at start, or gradually spawn?
  // We'll spawn waves at a faster pace and maintain a target total
  if(state.zombiesToSpawn > 0){
    state.lastSpawn += dt;
    if(state.lastSpawn >= state.spawnInterval){
      state.lastSpawn = 0;
      // spawn one or multiple based on level
      const to = Math.min(3, state.zombiesToSpawn);
      for(let i=0;i<to;i++){ spawnZombie(state.level); state.zombiesToSpawn--; }
    }
  }

  // player movement: keyboard for desktop
  if(state.mode === 'desktop'){
    let mx=0,my=0;
    if(keys['w']||keys['arrowup']) my -= 1;
    if(keys['s']||keys['arrowdown']) my += 1;
    if(keys['a']||keys['arrowleft']) mx -= 1;
    if(keys['d']||keys['arrowright']) mx += 1;
    const mag = Math.hypot(mx,my);
    if(mag>0){ p.vx = (mx/mag)*p.speed; p.vy = (my/mag)*p.speed; } else { p.vx=0; p.vy=0; }
    if(mouseDown) tryShoot();
  } else {
    // mobile: movement already applied by joystick to p.vx/p.vy
  }

  // apply velocity
  p.x += p.vx * dt/1000; p.y += p.vy * dt/1000;
  p.x = clamp(p.x, 8, W-8); p.y = clamp(p.y, 8, H-8);

  // bullets update & collision
  for(let i=state.bullets.length-1;i>=0;i--){
    const b = state.bullets[i];
    b.x += b.vx * dt/1000; b.y += b.vy * dt/1000;
    b.life -= dt;
    if(b.life <= 0 || b.x < -40 || b.x > W+40 || b.y < -40 || b.y > H+40){
      state.bullets.splice(i,1); continue;
    }
    // check collision with zombies
    for(let j=state.zombies.length-1;j>=0;j--){
      const z = state.zombies[j];
      if(dist(b.x,b.y,z.x,z.y) < b.r + z.r){
        z.hp -= b.dmg;
        state.bullets.splice(i,1);
        if(z.hp <= 0){
          // handle explosion or boss death
          if(z.explode){
            // damage nearby entities including player
            for(let k=state.zombies.length-1;k>=0;k--){
              const z2 = state.zombies[k];
              if(dist(z.x,z.y,z2.x,z2.y) < (z.explodeRadius + z2.r)){
                z2.hp -= 1;
                if(z2.hp <= 0){ state.score += z2.score; state.zombies.splice(k,1); }
              }
            }
            // player damage if close
            if(dist(z.x,z.y,p.x,p.y) < z.explodeRadius + p.r){
              p.health -= 8;
            }
          }
          // reward
          state.score += z.score || 10;
          state.zombies.splice(j,1);
        }
        break;
      }
    }
  }

  // zombies move & collide with player
  for(let i=state.zombies.length-1;i>=0;i--){
    const z = state.zombies[i];
    const dx = p.x - z.x, dy = p.y - z.y;
    const d = Math.hypot(dx,dy) || 1;
    z.x += (dx/d) * z.speed * dt/1000;
    z.y += (dy/d) * z.speed * dt/1000;
    // collision with player
    if(dist(z.x,z.y,p.x,p.y) < z.r + p.r){
      // damage depending on type
      let dmg = 8;
      if(z.type === 'runner') dmg = 6;
      if(z.type === 'tank') dmg = 14;
      if(z.boss) dmg = 18;
      p.health -= dmg;
      // remove zombie or reduce hp
      z.hp -= 1;
      if(z.hp <= 0){
        state.score += z.score || 10;
        state.zombies.splice(i,1);
      } else {
        // push zombie slightly back to avoid stacking
        z.x -= (dx/d) * 12;
        z.y -= (dy/d) * 12;
      }
      if(p.health <= 0) { onPlayerDeath(); return; }
    }
  }

  // update HUD & win condition
  document.getElementById('score').textContent = Math.floor(state.score);
  document.getElementById('health').textContent = Math.max(0, Math.floor(p.health));
  document.getElementById('zleft').textContent = state.zombies.length + state.zombiesToSpawn;
  // win condition: level cleared (no active zombies and none left to spawn)
  if(state.zombies.length === 0 && state.zombiesToSpawn === 0){
    // level complete
    advanceLevel();
  }
}

/* ---- Level system ---- */
function setupLevel(level){
  state.level = level;
  // compute how many zombies for this level
  // base count increases, with occasional boss
  let base = Math.round(6 + level * 1.6 + (level/3));
  if(level % 10 === 0) {
    base = Math.max(base, 8) + 1; // boss level adds a boss plus fewer adds
    // ensure we place a boss
  }
  state.zombies = [];
  state.bullets = [];
  state.zombiesToSpawn = base;
  state.spawnInterval = clamp(1000 - level*8, 180, 1400);
  state.lastSpawn = 0;
  state.player.x = W/2; state.player.y = H/2;
  state.player.health = Math.min(100, state.player.health + 10); // small heal
  // If it's a boss level, schedule a boss spawn earlier
  if(level % 10 === 0){
    // reduce normal spawn a bit, force a boss spawn after a short delay
    state.zombiesToSpawn = Math.max(0, base - 2);
    // spawn boss after 900ms
    setTimeout(()=> spawnZombie(level,'boss'), 900);
  }
  // update UI
  document.getElementById('level').textContent = level;
  document.getElementById('waveNum').textContent = level;
  document.getElementById('waveType').textContent = (level % 10 === 0) ? 'Boss Level' : 'Standard';
  updateBestDisplays();
}

/* advance to next level (up to MAX_LEVEL) */
function advanceLevel(){
  if(state.level >= MAX_LEVEL){
    // final victory
    showGameOver(true);
    return;
  }
  // small inter-level delay & bonus
  state.score += Math.max(0, Math.floor(30 + state.level * 4));
  setupLevel(state.level + 1);
}

/* ---- Player death & Game Over ---- */
function onPlayerDeath(){
  state.running = false;
  // update bests
  if(state.score > state.bestScore) state.bestScore = Math.floor(state.score);
  if(state.level > state.bestLevel) state.bestLevel = state.level;
  localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel}));
  showGameOver(false);
}

/* ---- UI: overlays & start ---- */
const startOverlay = document.getElementById('startOverlay');
const mobileControls = document.getElementById('mobileControls');
const hud = document.getElementById('hud');
const rightHud = document.getElementById('rightHud');
const levelInfo = document.getElementById('levelInfo');

function startGameWithMode(mode){
  state.mode = mode;
  state.player = createPlayer();
  state.player.health = 100;
  state.score = 0;
  state.zombies = [];
  state.bullets = [];
  state.running = true;
  state.paused = false;
  setupLevel(1);
  startOverlay.style.display = 'none';
  hud.style.display = 'block';
  rightHud.style.display = 'block';
  levelInfo.style.display = 'block';
  mobileControls.style.display = (mode === 'mobile') ? 'flex' : 'none';
  // reset sticks visually
  moveStick.style.transform = 'translate(0px,0px)';
  aimStick.style.transform = 'translate(0px,0px)';
  state.lastTs = performance.now();
}

document.getElementById('desktopBtn').addEventListener('click', ()=> startGameWithMode('desktop'));
document.getElementById('mobileBtn').addEventListener('click', ()=> startGameWithMode('mobile'));
document.getElementById('autoBtn').addEventListener('click', ()=>{
  const isMobile = /Mobi|Android|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent);
  startGameWithMode(isMobile ? 'mobile' : 'desktop');
});
document.getElementById('restartBtn').addEventListener('click', ()=>{
  document.getElementById('gameover').style.display = 'none';
  startOverlay.style.display = 'none';
  startGameWithMode(state.mode || 'desktop');
});
document.getElementById('changeBtn').addEventListener('click', ()=>{
  location.reload();
});

function showGameOver(victory=false){
  const go = document.getElementById('gameover');
  go.style.display = 'flex';
  document.getElementById('goTitle').textContent = victory ? 'You conquered the horde!' : 'You died';
  document.getElementById('goText').textContent = `Score: ${Math.floor(state.score)} • Reached level ${state.level}`;
  // update best displays
  updateBestDisplays();
}

/* update best score displays in HUD */
function updateBestDisplays(){
  document.getElementById('bestLevel').textContent = state.bestLevel;
  // persist if new bests
  if(state.score > state.bestScore) state.bestScore = Math.floor(state.score);
  if(state.level > state.bestLevel) state.bestLevel = state.level;
  localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel}));
}

/* ---- Main loop ---- */
function render(){
  // clear
  ctx.fillStyle = '#041219';
  ctx.fillRect(0,0,W,H);

  // subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let x=0;x<W;x+=64){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=64){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // draw bullets
  for(const b of state.bullets){
    ctx.fillStyle = '#ffd166';
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  }

  // draw zombies
  for(const z of state.zombies){
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath(); ctx.ellipse(z.x+4, z.y+8, z.r*1.1, z.r*0.6, 0, 0, Math.PI*2); ctx.fill();

    // body
    ctx.fillStyle = z.color || '#6fb98f';
    ctx.beginPath(); ctx.arc(z.x, z.y, z.r, 0, Math.PI*2); ctx.fill();
    // eyes / face detail
    ctx.fillStyle = '#071018';
    ctx.beginPath(); ctx.arc(z.x - z.r*0.28, z.y - z.r*0.22, Math.max(1.5, z.r*0.14), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(z.x + z.r*0.28, z.y - z.r*0.22, Math.max(1.5, z.r*0.14), 0, Math.PI*2); ctx.fill();
    // hp bar for big enemies
    if(z.hp > 1){
      const w = z.r*1.8;
      ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(z.x - w/2, z.y - z.r - 10, w, 6);
      ctx.fillStyle = '#ff595e'; ctx.fillRect(z.x - w/2, z.y - z.r - 10, w * clamp(z.hp / (z.boss ? (20 + state.level*4) : (1 + Math.floor(state.level/5))), 0,1), 6);
    }
    if(z.boss){
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(z.x, z.y, z.r+6, 0, Math.PI*2); ctx.stroke();
    }
  }

  // player
  const p = state.player;
  if(p){
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(p.x+4, p.y+8, p.r*1.1, p.r*0.6, 0, 0, Math.PI*2); ctx.fill();
    // body
    ctx.save(); ctx.translate(p.x,p.y);
    ctx.fillStyle = '#83c5be';
    ctx.beginPath(); ctx.arc(0,0,p.r,0,Math.PI*2); ctx.fill();
    // gun
    let ang = Math.atan2(state.pointer.y - p.y, state.pointer.x - p.x);
    ctx.rotate(ang);
    ctx.fillStyle = '#ffb703';
    ctx.fillRect(p.r-2, -6, p.r+18, 12);
    ctx.restore();
  }

  // HUD elements drawn via DOM
}

/* main tick */
function tick(ts){
  if(!state.lastTs) state.lastTs = ts;
  const dt = ts - state.lastTs;
  state.lastTs = ts;

  update(dt);
  render();

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---- Game loop helpers ---- */
function spawnInitial(level){
  // immediate small spawn to start
  for(let i=0;i<Math.min(3, state.zombiesToSpawn);i++){
    spawnZombie(level); state.zombiesToSpawn--;
  }
}

/* ---- Start behavior after setting up level ---- */
function setupLevel(level){
  setupLevelImpl(level);
  // quick initial spawn so player isn't empty
  setTimeout(()=> spawnInitial(level), 300);
}
function setupLevelImpl(level){
  state.level = level;
  if(!state.player) state.player = createPlayer();
  state.zombies = [];
  state.bullets = [];
  // zombie count scales with level
  let count = Math.round(6 + level * 1.6 + (level/3));
  if(level % 10 === 0) count = Math.max(count, 8) + 1;
  state.zombiesToSpawn = count;
  state.spawnInterval = clamp(1000 - level*8, 160, 1500);
  state.lastSpawn = 0;
  state.player.x = W/2; state.player.y = H/2;
  state.player.health = Math.min(100, state.player.health + 8);
  document.getElementById('level').textContent = level;
  document.getElementById('waveNum').textContent = level;
  document.getElementById('waveType').textContent = (level % 10 === 0) ? 'Boss Level' : 'Standard';
  updateBestDisplays();
}

/* Because we referenced setupLevel earlier, define advanceLevel and start flows properly */
function advanceLevel(){
  if(state.level >= MAX_LEVEL){
    // victory
    state.running = false;
    showGameOver(true);
    return;
  }
  state.score += Math.max(0, Math.floor(30 + state.level * 4));
  setupLevelImpl(state.level + 1);
}

function startGameWithMode(mode){
  state.mode = mode;
  state.player = createPlayer();
  state.player.health = 100;
  state.score = 0;
  state.zombies = [];
  state.bullets = [];
  state.running = true;
  state.paused = false;
  setupLevelImpl(1);
  startOverlay.style.display = 'none';
  hud.style.display = 'block';
  rightHud.style.display = 'block';
  levelInfo.style.display = 'block';
  mobileControls.style.display = (mode === 'mobile') ? 'flex' : 'none';
  moveStick.style.transform = 'translate(0px,0px)';
  aimStick.style.transform = 'translate(0px,0px)';
  state.lastTs = performance.now();
}

/* Re-bind start buttons (re-declare to pick our local impl) */
document.getElementById('desktopBtn').onclick = ()=> startGameWithMode('desktop');
document.getElementById('mobileBtn').onclick = ()=> startGameWithMode('mobile');
document.getElementById('autoBtn').onclick = ()=>{
  const isMobile = /Mobi|Android|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent);
  startGameWithMode(isMobile ? 'mobile' : 'desktop');
};

/* onPlayerDeath implementation (stores bests) */
function onPlayerDeath(){
  state.running = false;
  if(state.score > state.bestScore) state.bestScore = Math.floor(state.score);
  if(state.level > state.bestLevel) state.bestLevel = state.level;
  localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel}));
  showGameOver(false);
}

/* ---- Initial little spawn and helpers for saving ---- */
function updateBestDisplays(){
  document.getElementById('bestLevel').textContent = state.bestLevel;
  try { localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel})); } catch(e){}
}

/* make sure UI buttons that reference functions are linked */
document.getElementById('restartBtn').onclick = ()=> {
  document.getElementById('gameover').style.display = 'none';
  startGameWithMode(state.mode || 'desktop');
};
document.getElementById('changeBtn').onclick = ()=> { location.reload(); };

/* Pause on visibility change */
document.addEventListener('visibilitychange', ()=> { if(document.hidden) state.paused = true; });

/* small UX: focus / keyboard hints */
window.addEventListener('keydown', (e) => {
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='k'){ e.preventDefault(); }
});

/* Final polish: spawn a couple zombies at startup for flavor when overlay hidden */
setTimeout(()=> {
  // nothing started until player picks mode
}, 1200);

</script>
</body>
</html>
